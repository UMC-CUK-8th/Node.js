# 시니어 미션

- [x]  Soft Delete가 무엇인지 찾아보시고 soft delete에는 어떠한 HTTP Method가 들어가면 좋을지 적어주세요
    - 내용들을 간단하게 정리하여 주세요
        
        ### ✅ Soft Delete (논리 삭제)
        
        > 데이터베이스에서 특정 데이터를 **물리적으로 삭제(`DELETE`)** 하지 않고, 소프트웨어적으로 삭제하는, 즉 **삭제된 것처럼 처리하는 방식**을 의미
        > 
        
        ---
        
        ### [Soft Delete의 특징]
        
        - 실제 데이터는 DB에 **그대로 남아 있음**
        - `deleted`, `is_deleted`, `activated` 같은 **플래그 컬럼**을 사용하여 상태만 변경
        - 일반적으로는 `boolean` 타입의 컬럼을 사용:
            - `false` 또는 `null` → 정상 상태
            - `true` → 삭제된 상태
        
        ---
        
        ### [Soft Delete의 장점]
        
        - **데이터 보존**: 실수로 삭제해도 **복구 가능**
            - 데이터 복구가 필요한 도메인의 경우 hard delete을 한다면 사용자가 불편을 겪을 수 있음
        - **참조 무결성 보호**: `FK` 로 참조한 다른 테이블에 영향 없음
        - **속도 최적화 (특히 대용량 처리 시)**: `UPDATE`는 `DELETE`보다 ms 단위로 봤을 때 더 빠르게 동작
        - **디버깅에 유리**: 삭제된 데이터도 추적 가능
        - **다양한 활용 가능:** 로그, AI 학습, 법적 증거 등
        
        ---
        
        ### [Soft Delete의 단점]
        
        - **DB 용량 증가**: 삭제된 데이터가 계속 쌓임
        - **조회 시 필터링 필요**: 검색조건 시 삭제 처리된 레코드를 `SELECT` 조회하는 경우 반드시 `WHERE deleted = false` 같은 조건 필요
        - **복잡도 증가**: 실제로는 삭제되지 않았기 때문에 로직이 꼬일 수 있음
        
        ---
        
        ### [Soft Delete에 적합한 HTTP method]
        
        ### `DELETE`!!
        
        - HTTP 통신에서 **soft delete이냐 hard delete이냐는 신경쓰지 않아도 됨**
        - `PUT` 이나 `POST` 는 클라이언트에게 불친절, DB 중심적
        - 단, 실제로는 물리적 삭제가 아닌 **소프트 삭제로 처리됨**
        - 예시:
            
            ```
            DELETE /users/123
            ```
            
            - 위 method를 클라이언트에게 전달하고
            
            ```sql
            UPDATE users SET deleted = true WHERE user_id = 123;
            ```
            
            - 내부적으로는 위 코드처럼 처리

- [x]  컨트롤 URI에 대해 조사해주시고 어떠할 때 사용이 가능한 지 예시를 들어 설명해주세요.
    - 내용들을 간단하게 정리하여 주세요
        - 컨트롤 URI란?
            
            ### ✅ 컨트롤 URI (Control URI)
            
            > 단순한 CRUD를 넘어, 복잡한 프로세스 전환(상태 변경 등)을 처리하기 위한 URI
            > 
            - 리소스 중심의 RESTful 방식으로 표현하기 어려운 **행위(동작)**를 URI에 담아 처리하는 방식
            - 보통 `POST` + 동사형 경로로 표현됨
            
            ```jsx
            app.get('/users/mission', getUserMissions);
            ```
            
            → 여기서 `'/users/mission'` 가 바로 **컨트롤 URI**
            
            ---
            
        - 왜 컨트롤 URI를 사용할까?
            
            ## 컨트롤 URI가 사용되는 경우는 **크게 두 가지**
            
            | 사용 상황 | 설명 |
            | --- | --- |
            | ① **프로세스 상태 전이** | 단순한 리소스 수정이 아니라 **의미 있는 행위** (예: 승인, 활성화, 배송시작 등)를 표현해야 할 때 |
            | ② **HTML `form` 태그 제약 대응** | form은 `GET`/`POST`만 지원 → `PUT`, `PATCH`, `DELETE`는 못 씀 → **결국 동사형 URI로 우회해야 함** |
            
            ---
            
            ### 그런데 이 둘은 완전히 **별개가 아니라 연결된 현상임**
            
            ### 컨트롤 URI 필요
            
            - 단순한 CURD가 아니라 **행위**임 (프로세스 전이)
                - 그런데 이걸 HTML `form` 에서 호출하려니 HTTP method 제한이 있음 (`GET`, `POST` 만 사용 가능)
                    - 그래서 `/approve` , `/check` , `/delete` 같은 **동사형 URI 사용**
            
            | 구분 | 설명 | 관계 |
            | --- | --- | --- |
            | **프로세스 상태 전이** | **동작 자체**를 의미 있게 표현하기 위한 설계 | **본질적 이유 (행위 중심)** |
            | **form 제약** | GET/POST만 가능해서 어쩔 수 없이 동사형 URI 사용 | **기술적 제약 대응** |
            
            <aside>
            🗯️
            
            > 이건 의미 있는 행위다 → 그런데 PUT/PATCH 못 쓰니 POST /동사형으로 만들어야지
            > 
            </aside>
            
            ### 즉, 컨트롤 URI는 행위 중심 표현을 위한 방식이고 form 제약은 그것을 실전에서 필요로 하게 만드는 대표적인 사용 환경
            
            ---
            
        - 예시
            
            <aside>
            🗯️
            
            닉네임 변경 시 중복 확인을 예로 들어 컨트롤 URI의 사용에 대해 알아보자
            
            </aside>
            
            ### [닉네임 변경 시 중복 확인]
            
            - 사용자가 어떤 닉네임을 입력했을 때, 이미 존재하는지 아닌지 서버에 물어봐야 함
            - 즉, 어떤 리소스를 생성하는게 수정하는게 아닌 단순한 체크 로직
            
            ---
            
            ### [RESTful한 설계]
            
            ```
            GET /users/nickname?value=helen
            ```
            
            - 위 예시는 **닉네임**이라는 리소스가 존재한다는 전제로 설계된 URL임
            - 그러나 닉네임 자체가 리소스라고 보기엔 애매함
            
            ---
            
            ### [컨트롤 URI 활용]
            
            ```
            GET /users/nickname/check?nickname=helen
            ```
            
            - `/check`는 동사형 → **행위를 명시적으로 표현**
            - 리소스가 아니라 **동작을 호출하는 형태**
            - 보통 `GET`, 혹은 상황에 따라 `POST`로 사용됨
            
            ---
            
            ### [HTML form에서의 활용]
            
            ```html
            <form action="/users/nickname/check" method="POST">
            ```
            
            - form은 `POST`만 가능
            - `PATCH`처럼 더 적절한 HTTP 메서드가 있더라도 못 씀
            - 그래서 `POST /check` 같은 **컨트롤 URI** 사용
            
            ---
            
    
- [x]  https://learn.microsoft.com/ko-kr/azure/architecture/best-practices/api-design - 문서를 읽고 주요 내용을 간단히 정리해주세요.
    - 내용들을 간단하게 정리하여 주세요
        
        ### ✅ RESTful 웹 API 디자인 핵심 요약
        
        ### **REST란?**
        
        - **Representational State Transfer**
        - **리소스를 URI로 표현**하고, **HTTP 메서드(GET, POST 등)** 로 조작
        - **클라이언트-서버 간 분리**, **상태 비저장성**, **캐시 가능성**, **계층화된 구조**, **하이퍼미디어(선택적)** 등 제약 조건
        
        ---
        
        ### **RESTful API의 기본 설계 원칙**
        
        - **리소스 중심**: `/users`, `/orders/3`
        - **명사는 리소스**, **동사는 HTTP 메서드**로 표현
        - **리소스마다 고유한 URI를 가짐**
        - **URI는 최대한 간단하고 직관적으로**
        
        ---
        
        ### **HTTP 메서드 역할**
        
        | 메서드 | 설명 |
        | --- | --- |
        | `GET` | 리소스 조회 |
        | `POST` | 새 리소스 생성 또는 기능성 작업 트리거 |
        | `PUT` | 리소스 전체 수정 또는 생성 |
        | `PATCH` | 리소스 일부 수정 |
        | `DELETE` | 리소스 삭제 |
        
        ---
        
        ### **컨트롤 URI는 언제 쓰나?**
        
        - REST로 표현하기 **애매한 행위** (e.g. `/check`, `/activate`) → **컨트롤 URI**
        - `POST /nickname/check` → 닉네임 중복 확인처럼 **리소스 아닌 로직 트리거**
        - 특히 HTML form처럼 **GET/POST만 지원하는 환경**에 적합
        
        ---
        
        ### **URI 디자인 규칙**
        
        - 명사 사용 (e.g. `/orders`, `/users/1`)
        - 계층적 구조 (e.g. `/customers/1/orders`)
        - 복수형 사용 (e.g. `/products`)
        - `/create-user` 같은 동사형 URI는 사용하지 않음 (컨트롤 URI 제외)
        
        ---
        
        ### **버전 관리 방법**
        
        | 방식 | 예시 |
        | --- | --- |
        | URI 버전 | `/v1/customers/1` |
        | 쿼리 파라미터 | `/customers/1?version=2` |
        | 헤더 | `X-API-Version: 2` |
        | Accept 헤더 | `Accept: application/vnd.example.v2+json` |
        
        ---
        
        ### **상태 코드 사용**
        
        - `200 OK`: 일반 성공
        - `201 Created`: POST로 생성 성공
        - `204 No Content`: 응답 본문 없음
        - `400 Bad Request`: 요청 오류
        - `404 Not Found`: 리소스 없음
        - `409 Conflict`: 처리 충돌
        - `415 Unsupported Media Type`: 지원되지 않는 형식
        - `202 Accepted`: 비동기 요청 수락
        
        ---
        
        ### **추가 설계 고려 사항**
        
        - **HATEOAS**: 응답에 링크 포함 → 클라이언트가 URI 몰라도 리소스 탐색 가능
        - **페이지네이션/필터링**: `?limit=10&offset=20`
        - **불필요한 상세 URI 계층 깊이 피하기**
        - **단순한 계산 기능 등은 URI 기반 컨트롤 리소스로 처리 가능** (e.g. `/add?x=1&y=2`)
        
        ---
        

정리된 글을 바탕으로 블로그를 작성하여 주세요