# 시니어 미션

![내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)](Untitled%204.png)

내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함)

- [x]  미션 1(내가 진행중, 진행 완료한 미션 모아서 보는 쿼리(페이징 포함))에서 정렬 기준을 1순위는 포인트로 2순위는 최신순으로 하여 Cursor기반 페이지네이션을 구현해보세요
    - 내용들을 간단하게 정리하여주세요
        
        ```sql
        SELECT 
            um.user_id,
            um.mission_id,
            m.mission_name,
            m.reward_point,
            um.status,
            um.challenged_at,
            um.completed_at
        FROM 
            User_Mission um
        JOIN 
            Missions m ON um.mission_id = m.mission_id
        WHERE 
            um.user_id = '사용자 ID'
            AND um.status IN ('in_progress', 'completed') -- 진행 중이거나 완료된 미션만
            AND (
                m.reward_point < '마지막 미션 포인트' -- Cursor 포인트 조건
                OR (m.reward_point = ? AND um.completed_at < ?) -- Cursor 날짜 조건
            )
        ORDER BY 
            m.reward_point DESC, -- 1순위: 포인트 내림차순
            um.completed_at DESC -- 2순위: 완료일 내림차순
        LIMIT 
            10;
        
        ```
        

- [x]  SQL Injection에 대해 조사하고 어떠할 때 일어나고 어떻게 막을 수 있는 지를 적어주세요
    - 내용들을 간단하게 정리하여 주세요
        
        ### SQL Injection이란?
        
        > 웹 애플리케이션의 **입력값에 악의적인 SQL 문을 삽입**하여 DB에서 **원래 의도하지 않은 데이터를 조회하거나 수정, 삭제**할 수 있는 공격 기법이다. 주로 로그인, 검색, 회원가입, 게시글 등 **사용자 입력값을 처리하는 부분**에서 발생한다.
        > 
        
        ---
        
        ### SQL Injection이 발생하는 경우
        
        > 주로 입력값을 주로 SQL 쿼리에 연결할 때 발생한다.
        > 
        
        ### **1. 문자열 연결 방식으로 SQL 쿼리를 만들 때**
        
        ```sql
        SELECT * FROM users WHERE username = 'admin' AND password = '1234';
        ```
        
        이런 쿼리를 코드에서 다음처럼 만들면 문제가 된다
        
        ```jsx
        const query = "SELECT * FROM users WHERE username = '" + userInput + "'";
        ```
        
        사용자가 입력값으로 다음과 같이 넣는다면?
        
        ```vbnet
        ' OR 1=1 --
        ```
        
        그러면 최종 SQL은 다음처럼 된다.
        
        ```sql
        SELECT * FROM users WHERE username = '' OR 1=1 --';
        ```
        
        `1=1`은 항상 참이므로, 인증 없이도 로그인되는 등의 보안 문제가 발생
        
        ---
        
        ### SQL Injection 방지 방법
        
        ### 1. **Prepared Statement (Prepared SQL) 사용**
        
        SQL 쿼리의 구조와 데이터를 분리하는 방식
        
        ### 2. **ORM(Object-Relational Mapping) 사용**
        
        TypeORM, Sequelize, Django ORM, JPA 같은 ORM은 쿼리를 직접 작성하지 않고도 DB를 다룰 수 있어 Injection 가능성을 낮춤
        
        ### 3. **입력값 검증 및 필터링**
        
        - 입력값에서 SQL 문법에 해당하는 특수문자(`'`, `"`, `-`, `;`) 등을 제거하거나 제한
        - 정규 표현식을 이용해 유효한 형식만 통과
        
        ### 4. **DB 권한 최소화**
        
        웹 애플리케이션이 사용하는 DB 계정에는 **SELECT, INSERT 정도의 최소 권한만 부여**하고, `DROP`, `ALTER`, `GRANT` 등은 제한
        
        ### 5. **Web Application Firewall(WAF) 사용**
        
        웹 방화벽은 SQL Injection 시도 패턴을 탐지하여 사전에 차단해주는 역할
        

- [x]  다양한 JOIN 방법들에 대해 찾아보고, 각 방식에 대해 비교하여 간단히 정리해주세요.
    - 내용들을 간단하게 정리하여 주세요
        
        ## 1. INNER JOIN (내부 조인)
        
        > 두 테이블에서 **조건에 일치하는 행만** 반환
        > 
        
        ### SQL 예시
        
        ```sql
        SELECT *
        FROM employees e
        INNER JOIN departments d ON e.dept_id = d.id;
        ```
        
        ### 특징
        
        - 공통된 값이 있는 행만 출력
        - 가장 자주 사용됨
        
        ---
        
        ## 2. LEFT JOIN (또는 LEFT OUTER JOIN)
        
        > 왼쪽 테이블의 **모든 행**을 포함하고, 오른쪽 테이블에서 조건에 맞는 행만 포함
        일치하는 행이 없으면 NULL이 들어감
        > 
        
        ### SQL 예시
        
        ```sql
        SELECT *
        FROM employees e
        LEFT JOIN departments d ON e.dept_id = d.id;
        ```
        
        ### 특징
        
        - 왼쪽 테이블 기준으로 전체를 보여줌
        - 관계가 없는 데이터도 확인할 수 있음
        
        ---
        
        ## 3. RIGHT JOIN (또는 RIGHT OUTER JOIN)
        
        > 오른쪽 테이블의 **모든 행**을 포함하고, 왼쪽 테이블에서 조건에 맞는 행만 포함합니다.
        > 
        
        ### SQL 예시
        
        ```sql
        SELECT *
        FROM employees e
        RIGHT JOIN departments d ON e.dept_id = d.id;
        ```
        
        ### 특징
        
        - RIGHT JOIN은 LEFT JOIN과 반대 방향
        - 사용 빈도는 LEFT JOIN보다 낮음
        
        ---
        
        ## 4. FULL OUTER JOIN
        
        > 두 테이블의 **모든 행**을 포함하며, 일치하지 않는 행에는 NULL이 들어갑니다.
        > 
        
        ### SQL 예시 (일부 DB에서는 지원 안 함, MySQL은 직접 구현 필요)
        
        ```sql
        SELECT *
        FROM employees e
        FULL OUTER JOIN departments d ON e.dept_id = d.id;
        ```
        
        ### 특징
        
        - 일치하든 하지 않든 모든 데이터를 포함
        - PostgreSQL, SQL Server는 지원, MySQL은 `UNION`으로 대체 가능
        
        ---
        
        ## 5. CROSS JOIN (카테시안 곱)
        
        > 두 테이블의 **모든 행의 조합**을 반환 (조건이 없어 모든 경우의 수)
        > 
        
        ### SQL 예시
        
        ```sql
        SELECT *
        FROM products p
        CROSS JOIN colors c;
        ```
        
        ### 특징
        
        - `p`가 10개, `c`가 5개면 결과는 50행
        - 조합 분석이나 경우의 수 계산에 사용

정리된 글을 바탕으로 블로그를 작성하여 주세요