# Chapter 4. ES6와 프로젝트 파일 구조의 이해

<aside>
<img src="https://www.notion.so/icons/list_gray.svg" alt="https://www.notion.so/icons/list_gray.svg" width="40px" /> **목차**

</aside>

## 📝 학습 목표

1. ES6와 ES Module에 대해 이해하기
2. Node.js 서버 프로젝트의 기본적인 구조에 대해 이해하기

## 📸 잠깐! 스터디 인증샷은 찍으셨나요?

<aside>
💡 스터디장께서는 대표로 매 주차 스터디 인증샷을 남겨주세요!
사진을 저장하여 이미지 업로드할 수도 있고, 복사 & 붙여넣기를 통해 업로드할 수도 있습니다.

</aside>

[](https://www.notion.so)

## 📑 4주차 주제

Node.js를 본격적으로 사용하기 전, Node.js 서버 프로젝트의 구조를 이해하는 시간을 가져볼 예정입니다. Node.js 서버는 어떻게 통신하고, 어떤 요소들이 필요한지 알아봅니다.

## 🔖 4주차 본문

지난 주차에서 Node.js 설정은 잘 하셨나요?

그 때 저희는 Node.js 설치에 이어 Express, Nodemon 설정까지 진행했는데요, 이번 주차에서는 그 중 ES6와 프로젝트의 파일 구조에 대해 더 자세히 알아보는 시간을 가질 예정입니다.

### ⚾ ES6와 Babel

<aside>
💡 본격적으로 학습하기 전, JavaScript의 ES6, ES Module 등에 대한 개념을 되짚어볼게요!

</aside>

[Chapter 4. ES6와 프로젝트 파일 구조의 이해 - ES6와 ES Module](https://www.notion.so/Chapter-4-ES6-ES6-ES-Module-1cfb57f4596b81f19cb4f17c08a4a198?pvs=21)

### 🏗️ 프로젝트 파일 구조

<aside>
💡 Express 프로젝트의 파일 구조에 대해서 알아봅니다!

</aside>

[Chapter 4. ES6와 프로젝트 파일 구조의 이해 - 프로젝트 파일 구조](https://www.notion.so/Chapter-4-ES6-1cfb57f4596b81ea91a8e088c551cf19?pvs=21)

## 🎯 핵심 키워드

<aside>
💡 주요 내용들을 정리하고, 여러분만의 생각을 통해 정리해보세요!

- 레퍼런스를 참고하여 정의, 속성, 장단점 등을 적어주셔도 괜찮습니다.
- 조사는 공식 홈페이지 **Best**, 블로그(최신 날짜) **Not Bad**
</aside>

- ES
    
    ES( ECMA Script)란 Ecma international에서 ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어를 말한다.
    
- ES6
    - ES6의 주요 변화 및 특징
        1. **화살표 함수**
            
            기존의 함수 선언식이나 함수 표현식보다 좀 더 간결하며, 쉽게 사용하기 위해 고안됨
            
            C++, Python, Java 등 다양한 언어에서 사용하는 람다함수의 아이디어를 자바스크립트 문법으로 표현해 함수형 프로그래밍 스타일을 더욱 강화하고, 코드를 더 간결하고 가독성 좋게 작성할 수 있게 됨
            
            ⛔**제한점**
            
            - this, arguments나 super에 대한 자체 바인딩이 없고, 메서드로 사용해서는 아됨
            - [new.target](http://new.target) 키워드가 없음
            - 일반적으로 스코프를 지정할 때 사용하는 call( ), apply( ), bind( ) 메서드를 이용할 수 없음
            - 생성자 함수로 사용 할 수 없음
            - yield를 화살표 함수 내부에서 사용할 수 없음
            
            🖥️**사용법**
            
            ```jsx
            //JavaScript 일반 함수 선언식
            function add(a,b) {
            	return a+b;
            };
            
            add(1, 2); //3
            ```
            
            ```jsx
            //Java Script 일반 함수 표현식
            const add = function(a,b) {
            	return a + b;
            };
            
            add(1,2); //3
            ```
            
            ```jsx
            //JavaScript 화살표 함수
            const add = (a,b) => {
            	return a+b;
            };
            
            add(1,2); //3
            ```
            
        2. 함수 선언 방식
            - ES5: 객체 내에 있는 메서드를 실행하면 메서드의 this는 메서드가 선언된 해당 객체를 가리킨다.
            - ES6: this는 자신을 둘러싸고 있는 this를 바라보기 때문에 따로 바인딩이나 변수에 담을 필요 없이 사용 가능
        3. 템플릿 리터럴
            - ES5: 이미 준비되어있는 틀안에 해당하는 값만 상황에 알맞게 넣어서 사용
            - ES6: “ 백틱과 ${ }을 통해 한줄로 표기 가능하며 single quotation과 double 모두 자유롭게 사용 가능
        4. 객체 리터럴
            - 객체의 속성을 작성할 때 변수명과 동일한 경우 생략 가능
            - 객체 생성 시, 변수 값을 객체의 속성을 지정하는 경우 속성 값을 생략하여 표기 가능
        5. **클래스**
            - ES5: 지원 X
            - ES6: 공식적으로 클래스 지원
        6. 컬렉션
            - Set객체 - 중복을 제거한 값들의 집합
            - Map객체 - 키-값 쌍의 집합체이며, 키는 고유한 값이어야한다. Iteration 기반으로 만들어졌다. (키 순서가 보장된다)
            - WeakSet
            - WeakMap
        7. **모듈 (ESM)**
            
            ES5의 자바스크립트 파일은 script 태그로 분리해서 독자적인 모듈 스코프를 갖지 않았다.
            
            - 모듈 : 독립성을 가진 재사용 가능한 코드블록
            - import, export 구문을 이용해 모듈 가져오기 & 내보내기 가능
            
            모듈 내부에서 선언된 모든 변수, 함수, 객체, 클래스는 모두 지역적인 것 (local)로 간주된다. 따라서 외부로 공개하고자 하는 것은 export하고 다른 모듈에선 import 구문으로 참조하여 사용 가능하다.
            
            import 할 때 이름 변경하고 싶으면 `as` 예약어 사용
            
            import 할 때 단일 객체 (export default) 되었다면 구조분해할당 사용하지 않고 단일 객체로 가져온다.
            
            ```
            export default func;
            
            import func from './utils/func';
            ```
            
        8. **Promise**
            
            이전까진 AJAX 처리를 위한 비동기 작업을 수행할 때 비동기 처리가 완료되면 콜백함수가 호출되도록 작성했지만, 이 방법은 비동기로 처리해야할 작업이 많다면 콜백이 중첩되어 콜백헬을 만들어 예외 처리가 어려울 수 있다.
            
            ES6부터는 Promise 객체를 지원해 비동기 처리를 보다 깔끔하게 수행할 수 있다.
            
        9. Spread Operator 전개 연산자
            
            ... 연산자를 함수의 인자로 사용하는 경우 **가변 파라미터 (Rest Parameter)**라고 부른다.
            
            rest parameter는 개별 값을 나열하여 함수의 인자로 전달하면 함수의 내부에서 배열로 사용할 수 있도록 한다.
            
            spread operator는 rest parameter와 사용법이 다르다.
            
            배열이나 객체를 ...와 함께 객체 리터럴, 배열 리터럴에서 사용하면 분해된 값으로 전달된다.
            
            ```
            let obj1 = { name: 'melon', age: 20 };
            let obj2 = { ...obj1 };
            let obj3 = { ...obj1, nationality: 'KR' };
            
            console.log(obj1 === obj2); // false
            console.log(obj2); // { name: 'melon', age: 20 }
            console.log(obj3); // { name: 'melon', age: 20, nationality: 'KR' };
            
            let arr1 = [ 1, 2, 3 ];
            let arr2 = [ 'apple', ...arr1, 'pineapple' ];
            
            console.log(arr2); // ['apple', 1, 2, 3, 'pineapple']
            ```
            
        10. let & const
            
            ### var
            
            - 중복 선언 가능
            - 함수 스코프
            
            ### let
            
            - 재할당 가능
            - 중복 선언 불가능
            - 블록 스코프
            
            ### const
            
            - 재할당 불가능
            - 중복 선언 불가능
            - 블록 스코프
            - 선언과 동시에 초기화
        11. 구조분해할당
            
            배열, 객체의 값을 추출하여 여러변수에 할당할 수 있는 기능
            
            ```
            let arr = [1, 2, 3, 4];
            let [a1, a2, a3] = arr;
            console.log(a1, a2, a3); // 1, 2, 3
            
            let obj = { name: 'melon', age: 30, nationality: 'KR' };
            let { name: n, age: a, nationality } = obj;
            console.log(n, a, nationality); //melon 30 KR
            ```
            
    - ES6를 중요시 하는 이유
        
        ES Module이 도입되기 전 JavaScript 프로그램들은 대체로 작은 편이었습니다. 처음에는 브라우저 환경에서 약간의 스크립트 기능으로 활용되던 것이 점차 확대되고 복잡해지면서, JavaScript 파일들을 분리하고 필요할 때 가져올 수 있도록 개선할 필요가 생겼습니다.
        
        CommonJS와 비교해 모듈 내에서 내보내기(외부에 공개)를 처리하는 방법이 더 명확하고 유연해졌고, 모듈을 로드할 때에도 동기가 아닌 비동기로 처리하도록 변경되었습니다.
        
- ES Module
    
    이 ES Module입니다. (줄여서 esm으로도 부릅니다.) ES Module은 `require` 대신 `improt`, `export`를 이용해서 라이브러리와 모듈을 더 안전하고 효율적으로 가져오고 로드할 수 있습니다.
    
- 프로젝트 아키텍처
    - 프로젝트 아키텍처가 중요한 이유
        
        사전에 프로젝트 구조를 잡지 않는다면 프로젝트가 확장됨에 따라 로직이 여러차례 바뀌게 되고 데이터 의존성이 뒤죽박죽 되기 십상이기 때문에
        
        [개발자에게 아키텍처가 중요한 이유](https://devent.tistory.com/185)
        
    - Service-Oriented Architecture(Service Layer Pattern)
        
        ![[https://celeroncoder.github.io/blog/posts/should-i-adopt-service-oriented-architecture-soa/](https://celeroncoder.github.io/blog/posts/should-i-adopt-service-oriented-architecture-soa/)](31560.png)
        
        [https://celeroncoder.github.io/blog/posts/should-i-adopt-service-oriented-architecture-soa/](https://celeroncoder.github.io/blog/posts/should-i-adopt-service-oriented-architecture-soa/)
        
        Service-Oriented Architecture는 비즈니스 로직의 분리를 목적으로 합니다. 다른 계층에 영향을 주지 않고 특정 계층만 수정하고 확장할 수 있기 때문에, 새로운 기능을 개발하면서 확장하거나 유지 보수할 때 유리하다는 장점이 있습니다.
        
    - MVC 패턴
        
        ![image.png](image.png)
        
        **Model - View  - Controller**
        
        사용자 (클라이언트)가 controller를 조작하면 controller는 model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 됨
        
        ### Model
        
        애플리케이션의 정보, 데이터를 나타냅니다. 데이터베이스, 처음의 정의하는 상수, 초기화값, 변수 등을 뜻한다. 
        
        ### View
        
        input 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타냅니다. 다시 말해 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당합니다. 데이타를 기반으로 사용자들이 볼 수 있는 화면입니다.
        
        ### Controller
        
        데이터와 사용자인터페이스 요소들을 잇는 다리역할을 합니다.
        
        즉, 사용자가 데이터를 클릭하고, 수정하는 것에 대한 "이벤트"들을 처리하는 부분을 뜻합니다.
        
        컨트롤러 또한 다음과 같은 규칙을 이해해야 합니다.
        
        https://m.blog.naver.com/jhc9639/220967034588
        
    - 그 외 다른 프로젝트 구조
        
        **1. MVP (Model-View-Presenter)**
        
        - **개념:** MVC에서 Controller 역할을 Presenter가 대신합니다. View는 Presenter를 통해 Model과 상호작용하며, Model은 Presenter에게 데이터를 제공합니다. View와 Model 간의 직접적인 의존성을 없앤 것이 특징입니다.
        - **장점:**
            - View와 Model의 의존성이 낮아져 유지보수가 용이해집니다.
            - Presenter와 Model은 독립적으로 테스트하기 용이합니다.
            - UI 로직과 비즈니스 로직이 분리되어 개발자 간 협업이 용이합니다.
        - **단점:**
            - View와 Presenter 간의 1:1 관계 때문에 클래스 수가 늘어날 수 있습니다.
            - View와 Presenter 간의 의존성이 높아질 수 있습니다.
        
        **2. MVVM (Model-View-ViewModel)**
        
        - **개념:** View는 ViewModel과 데이터 바인딩을 통해 연결됩니다. ViewModel은 View에 표시할 데이터를 관리하고 비즈니스 로직을 처리합니다. View는 ViewModel의 변경 사항을 자동으로 감지하여 업데이트됩니다.
        - **장점:**
            - View와 Model 간의 의존성이 없어 테스트 용이성이 높고 유지보수가 편리합니다.
            - 데이터 바인딩을 통해 View와 ViewModel 간의 코드 양을 줄일 수 있습니다.
            - UI 개발과 비즈니스 로직 개발을 독립적으로 진행할 수 있어 생산성이 향상됩니다.
        - **단점:**
            - ViewModel 설계가 복잡해질 수 있습니다.
            - 데이터 바인딩을 위한 추가적인 라이브러리 사용이 필요할 수 있습니다.
        
        **3. 클린 아키텍처 (Clean Architecture)**
        
        - **개념:** 소프트웨어 시스템을 독립적인 계층으로 분리하여 외부 환경(UI, 데이터베이스 등)의 변화에 영향을 받지 않도록 설계하는 것을 목표로 합니다. 핵심 비즈니스 로직은 가장 안쪽에 위치하며, 외부 계층은 내부 계층에 의존합니다.
        - **장점:**
            - 테스트 용이성이 매우 높습니다.
            - 유지보수 및 확장이 용이합니다.
            - 프레임워크, UI, 데이터베이스 등 외부 요소에 대한 의존성을 최소화합니다.
            - 비즈니스 로직에 집중할 수 있습니다.
        - **단점:**
            - 구조가 복잡하고 초기 설정에 많은 노력이 필요할 수 있습니다.
            - 계층 간 데이터 전달을 위한 매핑 코드가 증가할 수 있습니다.
        
        **4. 레이어드 아키텍처 (Layered Architecture)**
        
        - **개념:** 시스템을 역할에 따라 여러 계층으로 나누는 구조입니다. 일반적으로 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층 등으로 구성됩니다. 각 계층은 특정 역할만 수행하며, 하위 계층에만 의존합니다.
        - **장점:**
            - 각 계층별로 관심사가 분리되어 코드의 재사용성과 유지보수성이 향상됩니다.
            - 각 계층을 독립적으로 개발, 확장, 변경할 수 있어 변화에 유연하게 대처할 수 있습니다.
            - 각 계층별로 테스트가 용이합니다.
        - **단점:**
            - 계층이 늘어날수록 복잡해질 수 있습니다.
            - 엄격한 계층 구조는 때때로 불필요한 계층을 만들거나 성능 저하를 유발할 수 있습니다.
            - 하위 계층의 변경이 상위 계층에 영향을 줄 수 있습니다.
        
        **5. 헥사고날 아키텍처 (Hexagonal Architecture) / 포트와 어댑터 아키텍처 (Ports and Adapters Architecture)**
        
        - **개념:** 핵심 비즈니스 로직(Application)을 외부 요소(UI, 데이터베이스, 외부 서비스 등)로부터 격리시키는 구조입니다. Application은 Port라는 인터페이스를 통해 외부와 상호작용하며, 실제 외부 요소는 Adapter를 통해 Port에 연결됩니다.
        - **장점:**
            - 핵심 비즈니스 로직이 외부 환경에 독립적이므로 테스트가 용이합니다.
            - 외부 요소의 변경이 핵심 로직에 영향을 주지 않아 유지보수성이 높습니다.
            - 다양한 유형의 UI, 데이터베이스, 외부 서비스 등을 쉽게 통합할 수 있습니다.
        - **단점:**
            - 초기 설계가 복잡할 수 있습니다.
            - Port와 Adapter 인터페이스 설계에 신중해야 합니다.
- 비즈니스 로직
    
    비즈니스 로직 (Business Logic)은 소프트웨어 애플리케이션이 **특정 비즈니스 요구사항을 충족하기 위해 수행하는 규칙, 제약 조건, 알고리즘, 절차 등의 핵심 기능**을 의미합니다. 쉽게 말해, **"이 애플리케이션이 무엇을 해야 하는가?"** 에 대한 답을 담고 있는 부분입니다.
    
    비즈니스 로직은 단순히 데이터를 저장하고 검색하는 기본적인 데이터베이스 작업과는 다릅니다. 데이터에 의미를 부여하고, 비즈니스 규칙에 따라 데이터를 처리하며, 최종적으로 사용자에게 가치 있는 결과를 제공하는 역할을 합니다.
    
- DTO
    
    **데이터를 옮기는 객체” 역할**을 합니다. 저 **계층 사이사이 간 데이터를 전송할 때도 사용**이 됩니다. 또한, **클라이언트로부터 전송 받은 데이터를 객체로 변환할 때도 사용**
    

## 🧩 요약 정리

<aside>
💡

이번 주차 워크북을 정리해봅시다! 

이번 주차 워크북이 개념 중심이라면 개념을 정리하고, 실습 중심이라면 1개 이상의 실습 코드 분석 내용을 작성해주세요. (🎯 핵심 키워드에서 이미 정리한 내용은 제외해주셔도 괜찮습니다.)

</aside>

## ⚠️ 스터디 진행 방법

**1. 스터디 전 준비**

- 핵심 키워드와 미션을 모두 수행해 주세요.
- 워크북을 진행하면서 모르는 부분이나 질문하고 싶은 내용이 있다면 정리해 주세요.

**2. 스터디 시간**

- 서로 질문하고 답변해 주세요.
    - 워크북을 진행하면서 몰랐던 부분이나 미션 피드백을 통해 생긴 질문을 공유하고 답변해 주세요.
- 핵심 키워드와 미션을 공유해 주세요.
    - 각자가 정리한 핵심 키워드와 미션을 서로 공유해 주세요.
    - 파트장(또는 스터디장)은 파트원들의 수행 내용을 보고 피드백할 부분을 정리하여 전달해 주세요.
        - 스터디에 파트장이 없거나 인원이 부족한 경우, 이 과정은 생략할 수 있습니다.

**3. 스터디 후 회고**

- 스터디가 끝난 후, 배운 점과 새로 알게 된 점을 기록해 주세요.

<aside>
💌

스터디를 진행한 후에는 📮 [**스터디 피드백 구글 폼**](https://docs.google.com/forms/d/e/1FAIpQLSewNkp1eswtsPt50BKK_Gjsyi7KdPytgT24MysqNzAaroDBnw/viewform) 양식을 통해 스터디 피드백을 남겨주세요. 여러분의 솔직한 피드백으로 더 나은 워크북과 스터디를 만들어가고자 합니다. 많은 의견 부탁드립니다! 🙏

</aside>

## ✅ 실습 체크리스트

1. 

## ☑️ 실습 인증

<aside>
💡

웹 브라우저, IDE(VSCode 편집기) 및 터미널 이미지(스크린샷), 설명 등을 자유롭게 남겨주세요. 실습을 진행한 과정이 순차적으로 잘 드러나면 가장 좋습니다.

</aside>

> **GitHub 저장소 주소**
> 
> 
> https://github.com/… (자신의 GitHub 저장소 주소를 입력해주세요.)
> 
1. 

## 🔥 미션

<aside>
📍 **주의 사항**

- 결과물만 올리면 안되고, 중간 과정 또한 기록을 남겨주셔야 합니다. (DB 연결, 테이블 생성 등)
- **결과물과 중간 과정 모두 기록하여 제출**하라는 뜻입니다.
</aside>

### 🍒 공통 미션

다음 주차에 진행할 `API 및 프로젝트 설정 기초`를 위해

- **로컬 DB 준비해오기**
    - **실제 테이블이 생성된 것을 찍어서 제출**
- 이후 본인의 GitHub 저장소를 만들어 `README.md` 빈 파일만 하나 생성해 `main` 브랜치에 커밋해주세요.
    
    이번 워크북의 코드는 `feature/chapter-04` 브랜치에 올린 후,
    **해당 GitHub 링크를 본인 워크북에 포함해주세요. (위 실습 인증에 GitHub 저장소 주소 작성)**
    
    **❗main 브랜치에 올리지 말 것!** (브랜치 명 꼭 `feature/chapter-04` 아니어도 됨!) **❗**
    
    **❗main 브랜치는 11주차의 `무중단 CI/CD (GitHub Actions + AWS EC2)` 에서 사용 할 예정❗**
    

### 🧙‍♂️ 시니어 미션

- ECMAScript의 의미, 그리고 ES6 이후에는 각 버전에 따라 어떤 기능들이 새로 추가되었는지 찾고 정리해주세요.
- 워크북에서 소개한 프로젝트 아키텍처(Controller, Service, Data Access) 구조에 대해 더 정리하고, Data Access(DB) 레이어와의 결합도를 낮출 수 있는 구조를 고민해주세요.
- 클린 아키텍처(Clean Architecture)와 의존성(Dependency)의 방향에 대해서도 찾아본 후 정리해주세요.

## 💪 미션 기록

<aside>
🍀 미션 기록의 경우, 아래 미션 기록 토글 속에 작성하시거나, 페이지를 새로 생성하여 해당 페이지에 기록하여도 좋습니다!

하지만, 결과물만 올리는 것이 아닌, **중간 과정 모두 기록하셔야 한다는 점!** 잊지 말아주세요.

</aside>

## ⚡ 트러블 슈팅

<aside>
💡 실습하면서 생긴 문제들에 대해서, **이슈 - 문제 - 해결** 순서로 작성해주세요.

스스로 해결하기 어렵다면? 스터디원들에게 도움을 요청하거나 **너디너리의 지식IN 채널**에 질문해보세요!

</aside>

- ⚡ 이슈 작성 예시 (이슈가 생기면 아래 버튼을 클릭해 No. 1, No. 2, No. 3, … 으로 작성해서 트러블 슈팅을 꼭 해보세요!)
    
    **`이슈`**
    
    👉 앱 실행 중에 노래 다음 버튼을 누르니까 앱이 종료되었다.
    
    **`문제`**
    
    👉 노래클래스의 데이터리스트의 Size를 넘어서 NullPointException이 발생하여 앱이 종료된 것이었다. 
    
    **`해결`**
    
    👉  노래 다음 버튼을 눌렀을 때 데이터리스트의 Size를 검사해 Size보다 넘어가려고 하면 다음으로 넘어가는 메서드를 실행시키지 않고, 첫 노래로 돌아가게끔 해결
    
    **`참고 레퍼런스`**
    
    - 링크

## 🤔 참고 자료

[[개발자 면접준비]#1. MVC패턴이란](https://m.blog.naver.com/jhc9639/220967034588)

[자바스크립트 화살표 함수- 일반 함수와의 차이점과 쓰는 이유 - 코딩에브리바디](https://codingeverybody.kr/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%9D%98-%EC%9D%B4%ED%95%B4%EC%99%80-%EC%82%AC%EC%9A%A9%EB%B2%95/)

---

Copyright © 2024~2025 김수빈(엘빈), 최재영(제리) All rights reserved.