## 🎯 핵심 키워드

</aside>

- ES
    - ECMA Script
    - JScript, ActionScript 같은 스크립트 언어의 기초 제공
    - 표준화 : 여러 브라우저 간 호환성 문제를 해결하기 위해 등장함.
    - <주요 버전>
        1. ES3 : 초기 안정화 버전
        2. ES5 : JSON 지원, `strict mode`(* 엄격 모드 : 문법과 런타임 동작을 모두 검사하여, 실수를 에러로 변환하고 변수 사용을 단순화함.) 추가
        3. ES6 : 현대 JavaScript의 기반을 다진 대규모 업데이트.
    - <주요 개념>
        1. 변수 선언 : `var`, `let,` `const`
        2. 객체 및 배열 디스트럭처링
        3. 모듈 시스템 : `import`, `export`
        4. 비동기 처리 : `Promise`, `async`/`await`
- ES6
    - ES6의 주요 변화 및 특징
        - <변수 선언 방식>
            1. `let`, `const` 추가 :
            1.1. `let` : 값 재할당 가능, 블록 스코프(블록({}) 내부에서 선언된 변수는 해당 블록에서만 접근 가능함.)를 가짐.
            1.2. `const` : 값 재할당이 불가능, 일정한 상수 값을 유지하며, 블록 스코프를 가짐.
            2. <화살표 함수>
            2.1. 기존의 `function` 대신 간결한 화살표 함수 사용.
        
        ```jsx
        ex) let sum (a, b) => a+b;
        ```
        
        - <템플릿 리터럴> : 문자열 표기법으로, 백틱(`)과 ${}를 사용함. 줄바꿈을 반영함.
        - <디스트럭처링(Destructuring)> : 배열과 객체를 쉽게 분해하여 변수에 할당.
        - <클래스> : 객체 생성 템플릿으로 함수로 호출하지 않음. 메소드 앞에 static을 붙이면 정적 메소드임.
        - <모듈화 시스템>
            1. named export :
            1.1. 여러 개를 `export`함.
            1.2. `import`와 동일 이름을 사용하며 다른 이름으로 `import`할 경우, as / *as를 사용함.
            2. default export :
            2.1. 하나씩 `export`함.
            2.2. `import` 이름을 신경쓰지 않아도 됨.
        - <스프레드 연산자>
            1. Rest Operator :
            1.1. 나머지 매개변수를 의미함.
            1.2. 후속 매개변수를 묶어 하나의 배열에 저장함.
            1.3. 매개변수 앞에 `...`를 붙여 사용하되, 마지막 변수여야 함.
            2. Spread Operator :
            2.1. 전개 구문을 의미함.
            2.2. 묶인 배열이나 객체를 개별적인 요소로 분리함.
            2.3. Rest의 반대 개념
            2.4. 분리할 매개변수 앞에 `...`를 붙임.
        - <배열 요소 순회/변형/집계>
            1. `forEach` : 배열의 각 요소에 대한 작업을 수행하되 결과를 저장하거나 반환하지 않음.
            2. `map` : 배열의 각 요소를 변형하여 결과값을 새로운 배열로 반환.
            => 위 둘은 배열 안 요소들을 1:1로 짝지음.
            3. `reduce` : 초기값 설정이 가능하고, 배열의 값을 축약(콜백 실행값 누적), 단일 값 반환
    - ES6를 중요시 하는 이유
        - 다양한 문법을 제시함으로써 생산성이 증가됨.
        - 모듈 시스템과 `class` 키워드를 통해 보다 구조적인 코드 작성이 가능, 유지 보수성이 증대됨.
        - 여러 브라우저, 프레임워크에서도 기능을 활용할 수 있으므로 호환성이 좋음.
        - 복잡한 패턴을 간단하게 만들 수 있음.
        => 전체적으로 코드의 가독성을 증가시켜 성능을 향상시키고 최적화시키는 데에 용이함.
- ES Module
    - ES6에 도입된 모듈 시스템.
    - 모듈은 함수와 변수를 모두 스코프에 넣고, 각 함수는 함수 스코프를 가짐.
    - `export`로 해당 변수, 함수를 '다른 모듈에서 `import`를 통해 의존할 수 있게' 지정이 가능함.
    - <장점>
        1. `import-export`의 명시적 관계로 손상 모듈 파악이 용이함. 즉, 의존성 파악에 용이함.
        2. 코드들을 독립적인 작동 가능 단위로 나누기 수월함. 모듈을 재사용함으로써 다양한 종류의 어플리케이션을 만들기도 가능함.
        3. `import-export`로 관계되지 않은 모듈 간의 오염은 발생하지 않음. 즉 코드 충돌을 방지.
    - <동작>
        1. 브라우저에서 ES Module은 구성, 인스턴스화, 평가의 단계를 거쳐 동작함.
        2. 파일을 불러오는 행위는 loader(HTML 명세서를 따름.)가 하며, script 태그에 `type="module"`을 적어두어 entry 파일로 지정함.
- 프로젝트 아키텍처
    - 프로젝트 아키텍처가 중요한 이유
        - 아키텍처는 프로젝트의 기초 구조를 설계하는 단계
        - <장점>
            1. 체계적인 계획 수립 : 전체적인 로드맵과 방향성을 명확히 제시하여 혼란을 줄일 수 있음.
            2. 확장성과 유지 보수성 : 프로젝트가 진행되어 규모가 커지거나 변수가 발생했을 때에 확장이나 유지 보수가 용이함. 특히 모듈화된 구조의 경우, 특정 부분 업데이트/교체가 가능함.
            3. 품질 및 안정성 향상 : 명확하고 일관된 아키텍처는 버그 발생 가능성을 줄이고, 시스템의 안정성을 향상시킴.
            4. 팀 커뮤니케이션 개선 : 프로젝트의 기술적 구조를 시각적으로 보여줌으로써 커뮤니케이션ㅣ 용이함.
            5. 기술 선택 및 적합성 : 아키텍처는 사용해야 할 기술, 프레임워크, 도구를 선택하는 기준이 되므로, 적합한 기술 스택을 정의하여 효율성을 높임.
    - Service-Oriented Architecture(Service Layer Pattern)
        - 서비스 인터페이스(UI)를 통해 소프트웨어 구성 요소의 재사용과 상호 운용성을 가능하게 하는 방법을 정의함.
        - 시스템을 독립적으로 구성하여 서로 통합하는 방식.
        - 공통 인터페이스 표준과 아키텍처 패턴을 사용하므로 새로운 어플리케이션에 신속하게 통합이 가능함.
        - <주요 개념>
            1. 비즈니스 로직의 중앙 집중화
            2. 서비스의 재사용성
            3. 유지 보수성과 확장성 : 코드가 모듈화되어 있어 변경이 필요할 때 특정 서비스만 수정이 가능함.
        - <구성 요소>
            1. 서비스 인터페이스 : 클라이언트와 서비스 간의 상호작용을 정의
            2. 서비스 구현 : 비즈니스 로직을 실제로 수행하는 부분
            3. 데이터 액세스 레이어 : 데이터베이스나 외부 시스템과 상호 작용하여 필요한 데이터를 제공함.
    - MVC 패턴
        - Model-View-Controller 패턴
        - 소프트웨어 설계와 아키텍처를 위한 디자인 패턴 중 하나
        - 사용자 인터페이스를 가진 응용 프로그램에 사용
        - 손쉬운 개발과 유지 보수를 위해 데이터, 프레젠테이션, 프로세싱을 서로 분리함.
        - <주요 구성 요소>
            1. 모델 (Moder) :
            1.1. 핵심 데이터와 비즈니스 로직을 나타냄.
            1.2. 데이터 저장소와의 상호 작용, 데이터 처리 및 유효성 검사와 같은 작업 수행.
            1.3. 독립적으로 작동하며, 뷰와 컨트롤러와 직접적인 통신이 없음.
            2. 뷰 (View) :
            2.1. 사용자에게 보여지는 애플리케이션의 UI 부분.
            2.2. 모델에서 데이터를 받아 사용자에게 표시하고, 사용자의 입력을 컨트롤러에 전달함.
            2.3. 애플리케이션의 데이터 표시와 관련된 모든 작업을 처리함.
            3. 컨트롤러 (Controller)
            3.1. 사용자 입력을 처리하고, 애플리케이션의 흐름을 관리함.
            3.2. 뷰에서 전달된 사용자 입력을 분석하고, 적절한 모델 기능을 호출, 데이터를 조작하거나 업데이트함.
            3.3. 처리된 결과를 뷰에 전달하여 화면에 표시하게끔 함.
        - <설계 원칙>
            1. 각 구성 요소의 역할과 책임을 명확하게 구분 : 모두 독립적으로 작동해야함.
            2. 구성 요소 간의 결합도를 최소화 : 구성 요소 간의 직접적인 참조를 피하고 의존성을 최소화해야함.
            3. 코드의 재사용성과 확장성 고려 : 각 구성 요소는 재사용이 가능한 모듈로 개발되어야 함.
        - <장점>
            1. 각 요소가 명확하게 구별되어 있어, 코드의 가독성과 유지 관리가 용이함.
            2. 요소 간의 낮은 결합도로 인해, 코드의 재사용성이 높아지며 개별 구성 요소를 독립적으로 개발, 수정, 테스트할 수 있음.
            3. 동일 모델을 여러 뷰에서 사용이 가능하므로 애플리케이션의 유연성이 향상됨.
    - 그 외 다른 프로젝트 구조
        - <Event-Driven Architecture(EDA)>
            1. 이벤트 중심으로 시스템을 설계하여, 이벤트가 발생하면 해당 이벤트를 처리하는 핸들러가 작동.
            2. 비동기 작업 처리에 적합하며 확장성과 성능이 뛰어남.
        - <Microservices Architecture>
            1. 애플리케이션을 독립적으로 배포 및 실행할 수 있는 작은 서비스로 나눔.
            2. 기술 스택 선택이 자유로움
        - <Serverless Architecture>
            1. 서버 관리가 필요 없이 클라우드 플랫폼에서 코드를 실행함.
            2. 초기 설정이 간단하며 비용이 효율적이고 트래픽 변화에 자동으로 대응함.
        - <Hexagonal Architecture (Ports and Adapters Pattern)>
            1. 애플리케이션의 코어를 외부 시스템과의 상호 작용과 분리함.
            2. 테스트 용이성이 향상됨.
        - <Command Query Responsibility Segregation (CQRS)>
            1. 데이터 읽기와 쓰기를 분리하여 처리함.
            2. 고성능 애플리케이션, 이벤트 소싱 시스템
        - <Pipeline Architecture>
            1. 여러 단계를 가진 처리 파이프라인으로 데이터를 순차적으로 처리함.
            2. 각 단계는 특정 작업을 수행, 출력은 다음 단계의 입력이 됨.
            3. 데이터 처리 과정이 명확하게 정의되어 있으며 확장 가능하고 모듈화가 쉬움.
- 비즈니스 로직
    - 소프트웨어가 현실 세계의 문제를 해결하는 방법을 구체적으로 구현한 것. 즉, 애플리케이션의 비즈니스 요구 사항을 구현한 코드.
    - MVC 패턴으로 미루어 볼 때, 비즈니스 로직이 담긴. 즉, 사용자의 요구사항을 해결하기 위한 실직적인 코드가 담기는 layer는 오직 Service Layer로 제한되고 있음.
    - `Controller`가 Client의 요청을 받고 `Service Layer`에서 실질적으로 처리한 후 이 결과를 반환함. 이 과정에서 사용되는 모든 로직을 비즈니스 로직이라 일컬음.
    - <구성 요소>
        1. 도메인 규칙 : 특정 조직에서 사용되는 고유한 규칙을 정의함.
        2. 데이터 처리 : 입력 데이터를 바탕으로 유효성 검사를 수행함.
        3. 워크플로우 관리 : 여러 작업을 순차적/병렬적으로 처리하는 로직을 포함함.
    - <중요성>
        1. 유지 보수성
        2. 재사용성
        3. 시스템 안정성
- DTO
    - Data Transfer Object (데이터 전송 객체)
    - 프로세스 간에 데이터를 전달하는 객체를 의미함.
    - 코드는 존재하지 않고 전달하고자 하는 데이터만 담겨 있음.
    - 주로 데이터를 캡슐화하여 클라이언트와 서버 간의 상호작용, 데이터베이스와 애플리케이션 간의 데이터 전송에서 사용됨.
    - <특징>
        1. 단순성 : 데이터를 표현하는 필드와 `getter`/`setter` 메소드로만 구성됨.
        2. 계층 간 의존성 감소 : 데이터 구조를 캡슐화하여 각 계층이 서로 의존하지 않고 데이터를 주고 받을 수 있도록 함.
        3. API 설계에서 필수적 : 클라이언트에게 필요한 데이터만 노출하여 불필요한 정보를 차단할 수 있음.
    - <장점>
        1. 보안 강화
        2. 응답 크기 감소 : 네트워크 사용량 최적화
        3. 유지보수 용이성 : 특정 계층의 변경이 다른 계층에 영향을 덜 미침.

## 🧩 요약 정리

</aside>

1. ES : 표준화된 스크립트 언어로, JavaScript 표준화를 위한 규격이다. 
2. 주기적으로 기능이 업데이트됨에 따라 이름 뒤에 숫자가 붙으며 변화하고 있다. 가장 최근 업데이트 된 ES의 경우, ES6이다.
3. 프로젝트 아키텍처 : 프로젝트의 기초 구조를 설계하는 단계로서, 원활한 프로젝트를 위해 정확하고 효율적인 사용이 필요하다. 


</aside>

> **GitHub 저장소 주소**
> > 
1. https://github.com/meeeji

## 🔥 미션

### 🍒 공통 미션

다음 주차에 진행할 `API 및 프로젝트 설정 기초`를 위해

- 로컬 DB 준비해오기
    - 실제 테이블이 생성된 것을 찍어서 제출

## 💪 미션 기록

</aside>

- 미션 기록
    
    **로컬 DB 준비하기 - 실제 테이블이 생성된 것을 찍어서 제출.**
    
    ***Data Grip을 이용하여 테이블 생성하기***
    
    1. `schema` 생성 - 본인은 `work1`이라는 이름의 `schema`를 `localhost`에 생성하였다. ([Chapter 1. 워크북](https://www.notion.so/Chapter-1-Database-1b7b57f4596b80dc8918ca9769a63f78?pvs=21) 참조)
    
    ![image.png](Chapter%204%20ES6%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2%201cfb57f4596b8056be1cf9d6e44ed2cd/image.png)
    
    1. SQL 문을 활용해 테이블 작성 - 이 때, 앞서 작성했던 ERD를 활용했다.
    
    ![스크린샷 2025-04-02 오전 2.47.39.png](Chapter%204%20ES6%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2%201cfb57f4596b8056be1cf9d6e44ed2cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-04-02_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.47.39.png)
    
    > 활용한 ERD
    > 
    
    ![스크린샷 2025-04-12 오후 2.25.56.png](Chapter%204%20ES6%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2%201cfb57f4596b8056be1cf9d6e44ed2cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.25.56.png)
    
    > User 테이블 생성문
    > 
    
    → 위와 같이 SQL 문을 작성하여 ERD에 표현되어 있는 총 13개의 테이블을 생성한다.
    
    ![스크린샷 2025-04-12 오후 2.26.08.png](Chapter%204%20ES6%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2%201cfb57f4596b8056be1cf9d6e44ed2cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.26.08.png)
    
    > 총 13개의 테이블을 생성한 모습
    > 
    
    ![스크린샷 2025-04-12 오후 2.44.02.png](Chapter%204%20ES6%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2%201cfb57f4596b8056be1cf9d6e44ed2cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.44.02.png)
    
    > 작성한 테이블을 다이어그램으로 표현한 모습
    > 
    
    1. 로컬 DB로 잘 생성되었는지 확인하기 위해 Work Bench 를 활용하였다.
    
    ![스크린샷 2025-04-12 오후 2.46.01.png](Chapter%204%20ES6%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2%201cfb57f4596b8056be1cf9d6e44ed2cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-04-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.46.01.png)
    
    > Work Bench를 활용하여 보아도 잘 설정된 모습을 확인할 수 있다.
    > 